h1. Comparative Languages: Community is Everything

Over the past year one of my main technical interests has been exploring and comparing various programming languages.  I'm not exploring the boundaries of linguistic obscurity like "Steve J":http://saladwithsteve.com/; I want to borrow ideas from other languages that I can incorporate in my daily work and evaluate potential future tools.  (Any programmer who's satisfied with her tools isn't paying attention.)

There are endless metrics against which one can judge a programming language: the performance of programs, subjective readability, availability of libraries for common tasks,  availability of quality language primitives, &amp;c.  In my explorations, however, nothing matters more than the community surrounding a language when determining its overall success.

h2. A Happy Place

People program in Ruby because it's fun; it makes developers (of a certain persuasion) happy.  Happy developers evangelize, and thus a friendly, productive community has grown up around Ruby and Rails over the last several years.  Coming from the world of Java or PHP, the Ruby community is some brilliantly green grass.  Rubyists tend to be pleasant, articulate, and helpful.  That people write _cogently_ about Ruby is perhaps the community's greatest strength, and one that will surely be tested as the community swells with bulk-rate developers.

h2. A Chilly Place

2007 has been a big year for the visibility of functional languages like Lisp, Haskell, and OCaml, but no accessible community has yet formed around any of them.  Indeed, by "some accounts":http://nothinghappens.net/?p=217 the functional language community can be downright hostile.  In my experience, functional programmers can be a dry and academic lot.  Languages don't take off until someone with a sense for humane aesthetics starts evangelizing in a format that people enjoy consuming.  While "Paul Graham":http://www.paulgraham.com/ has waxed poetic about Lisp, it'll take more than his essays to warm people up to the functional way of thinking.

h2. A Scala Place

Former Java heads with an eye towards the more practical aspects of functional languages are flocking to "Scala":http://www.scala-lang.org/ which, as mentioned in "my previous post":http://www.al3x.net/2007/12/big-in-2008-dynamic-languages-atop-high.html, runs atop the JVM.  Scala, much like "ECMAScript 4":http://www.ecmascript.org/, has the potential to be the Next Big Language.  It's got constructs to handle most any style of programming, a superb approach to concurrency, and much more.  What may tie Scala down are its deep roots in the Java community.

That Scala builds on the strengths of the JVM and the plethora of available Java libraries makes good pragmatic sense.  It also means that knowing Scala means knowing Java, and in turn dealing with the Java community.  That means things like ugly documentation, forums and IRC channels filled with miserable code and incomprehensible language, Sun's endless cheesy marketing, and a pervading sense of _enterpriseyness_.  Java isn't cool, it's Serious Business.

Converts from Java to Ruby haven't made the switch because Ruby is faster, or better at concurrency, or deployable in a broader range of environments, or better supported.  They haven't reinvented the wheel in Ruby with new build systems, documentation setups, and libraries because doing so makes good pragmatic sense.  Quite the contrary, on all counts.  Developers have chosen Ruby because of the community.  They've reinvented the wheel so many times over to keep tools within the Ruby community, where things are nice.

None of the above hassles will deter those familiar with the Java community to dive into Scala, and talented developers are already doing so.  For developers that have had the pleasure of largely avoiding Java for the past few years, Scala is a harder sell.  For us, the Java community is an albatross around Scala's neck.  The question is whether Scala's benefits will outweigh that negative.