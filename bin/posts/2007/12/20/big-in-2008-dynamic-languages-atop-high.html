<h1>Big in 2008: Dynamic Languages atop High-Level Languages</h1>
If you'll allow for some generalization, the mainstream programming language stack basically looks like this:<br /><br /><div style="text-align: center;"><img src="http://lh6.google.com/al3xanderpayne/R2rJNCc3ahI/AAAAAAAAAEU/EnYLkQ8zGB4/stack%201.png?imgmax=800" alt="Stack 1" border="0" height="256" width="236" /></div><br /><br />Dynamic, interpreted languages at the top, nitty-gritty close-to-the-machine languages at the bottom.  It hasn't always been this way, of course, but that's certainly been the stack for the last few years.  Lately, though, something's been changing.  There's a new layer on the stack, and now it looks like this:<br /><br /><div style="text-align: center;"><img src="http://lh4.google.com/al3xanderpayne/R2rJwic3aiI/AAAAAAAAAEc/2JHzSuC-1iA/stack%202.png?imgmax=800" alt="Stack 2" border="0" height="318" width="236" /></div><br /><br />Now we've got dynamic languages running on top of interpreted languages, and in some cases atop other dynamic languages.  Some of these languages at the top of the stack have been in development for years, but my assertion is that 2008 will be the year that they see increased adoption across the industry.<br /><h4>Why?</h4>Abstraction means increasing returns in developer productivity.  Implementing a non-trivial language in C is a hellacious challenge; implementing it in a language like Java, apparently less so given the relatively rapid time-to-market of projects like JRuby.  Environments like the Java Virtual Machine (JVM) and and Microsoft's .NET Common Language Infrastructure (CLI) are written for performance and portability.  Building on a powerful VM or runtime environment allows a language implementor to inherit some powerful traits.<br /><br />If this trend of was only happening on the JVM and CLI it would be notable but hardly worth going on about.  What made me take pause was the emergence of <a href="http://programming.nu/">Nu</a> and <a href="http://chopine.be/lrz/diary/2007-12-07_ruby-objc-Part-1.html">ruby+objc</a>.  Nu looks like Lisp, and ruby+objc will look like Ruby, but the goal is the same: build a language that gets the Objective-C runtime to do the dirty work and focus on a pleasurable syntax and higher-level abstractions.  Implementing the language directly on the runtime has the added benefit of doing an end-run around the problems of bridging languages.<br /><br />Portable runtimes are big engineering efforts, typically the province of the Suns, Microsofts, and Apples of the computing world.  It's understandable that big engineering shops would gear their runtimes towards industrial-strength languages like Java, C#, and Objective-C.  But there are plenty of projects for which an industrial-strength language is an impediment, not a boon.  Having access to a dynamic language on top of your favorite industrial-strength high-level language is an incredibly useful tool in a programmer's toolbox.<br /><h4>Proving the Trend</h4>Runtime-by-runtime, here's a list of the languages at the top of the stack in 2008:<br /><br /><strong>JVM</strong><br /><ul><li><a href="http://www.scala-lang.org/">Scala</a> - "a general purpose programming language [...], concise, elegant, and type-safe, [...] smoothly integrates features of object-oriented and functional languages"<br /></li><li><a href="http://jruby.codehaus.org/">JRuby</a> - Ruby for Java</li><li><a href="http://www.jython.org/">Jython</a> - Python for Java</li><li><a href="http://groovy.codehaus.org/">Groovy</a> - "an agile and dynamic language for the Java Virtual Machine"</li><li><a href="http://www.robert-tolksdorf.de/vmlanguages.html">so very many more</a></li></ul><strong>.NET CLI</strong><br /><ul><li><a href="http://boo.codehaus.org/">Boo</a> - "a new object oriented statically typed programming language"</li><li><a href="http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython">IronPython</a> - Python on the.NET CLI</li><li> <a href="http://www.ironruby.net/">IronRuby</a> - Ruby on the .NET CLI</li><li><a href="http://research.microsoft.com/fsharp/fsharp.aspx">F#</a> - ML on the .NET CLI, "provides [...] type safety, performance and scripting"<br /></li><li><a href="http://en.wikipedia.org/wiki/CLI_Languages">really quite a few more</a>, albeit not as many as on the JVM</li></ul><strong>Objective-C</strong><br /><ul><li><a href="http://programming.nu/">Nu</a> -  Lisp for Cocoa</li><li><a href="http://chopine.be/lrz/diary/2007-12-07_ruby-objc-Part-1.html">ruby+objc</a> - Ruby for Cocoa</li><li><a href="http://www.fscript.org/">F-Script</a> - Smalltalk for Cocoa</li></ul>Even more out there, here are languages implemented atop dynamic languages, some experimental, some practical:<br /><ul><li><a href="http://www.reductivelabs.com/projects/puppet/">Puppet</a> - a "simple declarative specification language [...] written entirely in Ruby" for systems management.  We're using Puppet to manage our new cluster at Twitter.</li><li><a href="http://t-a-w.blogspot.com/search/label/rlisp">RLisp</a> - a Lisp implemented in Ruby</li><li><a href="http://bus-scheme.rubyforge.org/">Bus Scheme</a> - "a Scheme written in Ruby, but implemented on the bus!</li><li><a href="http://www.pypy.org">PyPy</a> - Python implemented in Python (but it's actually way more than that)<br /></li></ul>At any rate, something to watch in aught-eight.  I'd be interested to hear if any of the above languages are on your radar.